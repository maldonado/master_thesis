% -*- root: cuthesis_masters.tex -*-  

Software systems are everywhere. It does not matter anymore what is the domain in question, the truth is software will be present and it will be important. Virtually every business in every sector depends on software systems to aid in the development, production, marketing, and support of its products and services. 

The technological advance allowed unprecedented advance. Many innovations in the fields of robotic manufacturing, nanotechnologies, and human genetics research all have been possible due the aid provided by computers and software.

However, one major implication of the technological advance is that quality matters. The impact of software quality is huge, a faulty software can bankrupt companies and individuals, it can expose sensitive information or even threat lives. For example, in 2012 Knight Capital, a specialized firm in executing trades for retail brokers, took \$440 millions in cash losses due to an error in a trading algorithm~\cite{Register:trading_algorithm}. In 2014, air traffic controllers lost voice contact with 400 airplanes they were tracking over the southwestern United States when the main voice communications system shut down unexpectedly~\cite{IEEESpectrum:airtraffic}. The US National Institute of Standards and Technology (NIST) estimated that software faults and failures cost the US economy 59.5 billion dollars a year \cite{NIST:economic_impacts}. 

At the core of software systems are software developers. Their decisions and expertise is what makes the difference between faulty and reliable software. However, keep a high quality level software project is not easy, and it has been proven to be a rather complex achievement. During the development of a software project software developers have to deal with conflicting goals that require software to be delivered quickly, with high quality, and on budget. In practice, achieving all of these goals at the same time can be challenging, causing a tradeoff to be made. Often these tradeoff means shortcuts and the implementation of sub-optimal solutions. These workarounds allows the project to move faster at the cost of its increased maintenance effort in the future. This phenomena is called \emph{technical debt}. 

Prior work has shown that technical debt is widespread in the software domain, is unavoidable, and can have a negative impact on the quality of the software \cite{Lim2012Software}. Due to the importance of technical debt, a number of studies empirically examined technical debt and proposed techniques to enable its detection and management. Most approaches to identify technical debt is based on static source analysis tools, as described in greater detail in Chapter \ref{literature_review}. 

However, there are limitations to these approaches. First, static analysis tools depends on arbitrary metrics and thresholds to detect technical debt, and deriving appropriate threshold values is a challenging open problem that has attracted the attention and effort of several researchers ~\cite{Oliveira2014CSMR,Fontana2015WETSoM,Fontana2015EMSE}. As a matter of fact, the approaches based on source code analysis suffer from high false positive rates~\cite{Fontana2016SANER}. Second, static analysis tools requires the construction of Abstract Syntax Trees or other more advanced source code representations. For instance, some code smell detectors that also provide refactoring recommendations to resolve the detected code smells~\cite{Tsantalis2011TSE,Tsantalis2015TSE} generate computationally expensive program representation structures, such as program dependence graphs~\cite{Graf2010SCAM}, and method call graphs~\cite{Ali2012ECOOP} in order to match structural code smell patterns and compute metrics.

More recently, another venue was explored to enable identification of technical debt, the use of source code comments. Potdar and Shihab~\cite{Potdar2014ICSME} devised an approach of 62 comment patterns (i.e., words and phrases) that was used by software developers to indicate ``not quite right code''. The detection of technical debt through source code comments does not suffer of the same limitations that static analysis tools as it is a more lightweight process that does not depend of source code representations, and does not depend on thresholds of any kind as the developers themselves are admitting the debt. Due to its nature, technical debt found in source code comments is referred as \emph{\SATD}.

% However, their approach does not take into consideration the different types of technical debt. Understanding the different types of self-admitted technical debt is important since: 1) it helps the community understand the limitations of understanding technical debt through code comments, 2) it allows us to complement existing technical debt detection approaches and 3) it provides us with a better understanding of the developerâ€™s point of view of technical debt.
% Therefore, in this chapter we examine and quantify the different types of self- admitted technical debt. To do so, we extract source code comments from 5 well com- mented open source projects that belongs to different application domains, namely Apache Ant, Apache Jmeter, ArgoUml, Columba and JFreeChart. In total, we ex- amined more than 166K comments. We applied a set of 4 simple filtering heuristics to remove comments that are not likely to contain self-admitted technical debt (e.g., license comments, commented source code, Javadoc comments). Finally, these filter- ing heuristics resulted in a dataset of 33,093 comments that the first author manually analyzed and classified into different types of self-admitted technical debt.


\section{Research Hypothesis}

Prior research and our industrial experience lead us to the formation of our research hypothesis. We believe that:


