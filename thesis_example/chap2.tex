\chapter{Implementation}

\section{The Abstract Syntax Tree}
 
The heart of the Dee project is its Abstract Syntax Tree (AST).  Many
different parts of the Dee environment have an intimate relationship
with the AST.  The end result of the parsing phase of the compiler is
an AST.  The Class Interface Manager (CIM) then saves the parts of the
AST, which represent the interface of the class, in the class
interface data base (CIDB).  The {\tt ri} command, for browsing a
class, uses the CIM to read a class interface in the form of an AST.

The definition of the AST used in the Unix version of the Dee system
is not radically different from the one used in the PC Dee system.
The first task I undertook when beginning the Unix system
implementation was to convert the PC AST, written in Pascal, into C.
Several fields were dropped, added, or changed slightly to reflect the
new operating system and new Dee specification.  The new C AST was the
foundation on which all other parts of the Dee compiler were built.
Having this accurate data structure at such an early stage was crucial
to the success of our team of programmers.  It allowed us to work
separately on the different components of the system with only a
minimum of communication.  Wai Ming Wong was able to complete the
alpha version of the semantic analyzer without having an AST to work
with.  After I completed the scanner/parser phase of the compiler, it
became possible to test the semantic analyzer with real ASTs.  The
careful specification of the AST allowed us to put these two large
components of the system together with virtually no changes (other
than bug fixes).  In a similar manner, I was able to complete a
substantial portion of the code generator before I was ever able to
test it with a decorated AST as produced by the semantic analyzer.

An example of cooperation and communication between different
components of the Dee system via the AST can be seen in the example of
the {\tt Var} section of the AST presented in Figure \ref{fig:var}.
The complete AST definition can be found in Appendix~A.

\begin{shortfigure}
\begin{prog}  
\>      struct \{                     \\                                 
\>\>      StringPtr VarComment;     /* Comment following variable */  \\
\>\>      AST VarType;              /* Type of the variable       */  \\
\>\>      Boolean VarPublic;        /* True if public             */  \\
\>\>      AttriSrc AttributeSource; /* Where the variable is from */  \\
\>\>      AST SourceClass;          /* Added by the SA            */  \\
\>      \} Var;
\end{prog}
\caption{The {\tt Var} portion of the AST data structure.}
\label{fig:var}
\end{shortfigure}

Different fields of this variant of the AST structure are filled in by
different parts the compiler.  The parser fills in the {\tt
VarComment}, the {\tt VarType} and the {\tt VarPublic} fields.  This
information comes directly from the source of the class being
compiled.  The semantic analyzer then interacts with the CIM to fill
in the last two fields.  If there are no compilation errors, the parts
of the AST relevant to the class interface are written to the CIDB.
Finally, the entire decorated AST is passed to the code generator
where it is traversed one last time to produce code.


\section{The Scanner}

Scanning is the process of dividing the input stream into groups of
characters called tokens.  I have created two different scanners for
Dee.  The original scanner was generated by a scanner generator.
Because lexical analysis is considered to be one of the most time
consuming parts of the compilation process, a new hand-coded scanner
was written.  This second scanner is different in several ways.  It
resulted in a smaller compiler executable, but did not achieve a
significant speedup.

\subsection{The Generated Scanner}

The original scanner for Dee was generated by the standard Unix
utility {\em Lex} \cite{Lesk75}.  It has the advantage of being easy
to write and modify.  The specification of the scanner used by Lex is
only about 100 lines long.  The scanner it creates is compatible with
parsers generated by {\em Yacc}.

Lex takes as input a set of regular expressions \cite{Aho86,Fisher88}.
It then generates tables that are used by a finite automaton to
recognize tokens.  When each regular expression is matched, a
corresponding segment of user specified C code is executed.  This
segment of code does things like add symbols to the hash table, record
comments and string literals, and return the token type.

\begin{shortfigure}
\begin{prog}
[A-Za-z\_]([A-Za-z0-9\_])*                 \\
\>\>\>   \{                                    \\
\>\>\>\>     int t;                            \\
\>\>\>\>     t = Lookup(yytext);               \\
\>\>\>\>     if ( t == IDEN ) \{               \\
\>\>\>\>\>     yylval.IdenVal = Hash(yytext);  \\
\>\>\>\>\>     yylloc.last\_line = TokenLine;  \\
\>\>\>\>\>     return t;                       \\
\>\>\>\>     \}                                \\
\>\>\>   \}
\end{prog}
\caption{A Lex regular expression and its action.}
\label{fig:action}
\end{shortfigure}

The portion of the Lex specification for the Dee scanner in Figure
\ref{fig:action} recognizes identifiers and keywords.  The left column
is a regular expression describing a string of characters starting
with a letter or an underscore and followed by any number of
characters which may be a letter, number or underscore.  Whenever this
regular expression is matched, the C code on the right is executed.
Since this one regular expression describes both keywords and
identifiers, the C code checks a table to differentiate the two.  If a
keyword is found, its token value is returned to the parser.  If an
identifier is found, it is hashed and the token for an identifier is
returned to the parser.

Using a finite automaton is particularly well suited to scanner
generators because the code that interprets the tables does not depend
on the lexical structure of the language to be scanned.  It is only
the tables that change for each new set of regular expressions.
According to [Waite], this method of lexical analysis is not as
efficient as embedding the translation logic into a program.

{\em Flex} is a Lex compatible scanner generator which is slightly
more efficient than the original.  The specification file used by Lex
can be used, unaltered, by Flex.  Benchmarks used to compare generated
and hand-coded scanners were run on both Lex and Flex.

\subsection{The Hand-Coded Scanner}

Both \cite{Waite86} and \cite{Fraser91} make several suggestions for writing a
hand-coded scanner which I incorporated into the design of the new
Dee scanner.  The most important of these are the use of a large input
buffer and the indexing of a table based on the current input
character's ASCII value.  Using large buffers for source input was
carried to an extreme in my Dee scanner.

The most efficient way to read the source text into main memory is to
avoid reading amounts which would only partially fill a buffer.
Because disk controllers, the operating system and even the routines
that do the high-level reading may contain buffering, it is difficult
to know the optimal amount to read.  This problem has been minimized
in the hand-coded scanner by reading the entire source file with one
call to the operating system.  This allows each level of buffering to
perform optimally with the exception of the last buffer of the file,
which will probably be partially full.  In addition, this
significantly improves processing speed by eliminating the need for
checking when the end of a buffer is reached.  Now we need only check
for the end of the file.

Traditionally, entire source files were not read into main memory
because their size might exceed the compiler's (or the operating
system's) ability to hold them.  Classes tend to be small enough to
easily fit into the very large address spaces found on modern
hardware.  The logical size of a source file in Dee, and in most
object oriented programming languages, is one class.  The data in table
2 demonstrates the trend of these source files, to be rather small.
The numbers in the table are the sizes of files measured in bytes.
Because only a limited number of Dee classes have been written, I also
included data for classes of other object oriented programming
languages.  As the number of Dee classes rises, we can also expect the
average class size to increase.  This increase should bring the Dee
averages closer to those of the other languages cited.

\vspace{8mm}

\begin{tabular}{|l|r|r|} \hline
Language &  Avg. in bytes  & Max. in bytes  \\ \hline \hline
Dee      &  890   & 2822 \\ \hline
Eiffel   &  2370  & 5821 \\ \hline
C++      &  9746  & 18850 \\ \hline
\end{tabular}


\vspace{8mm}

The hand-coded scanner was also written to be compatible with parsers
generated by Yacc.


\subsection{The Two Scanners Compared}

In order to compare the speed of the two types of scanner I wrote a
test driver.  It does nothing but repeatedly call the scanner until
the end of file is reached.  I then created a shell script to run the
scanner, on a large class, 200 times.  This shell and the Unix {\tt
time} command combined to produce the average times listed in the
table below.  The time column indicates the total real-time the
command took to execute, measured in seconds.  The size column
indicates the size of the executable in bytes.

\vspace{8mm}

\begin{tabular}{|l|r|r|}  \hline
Scanner & Size in bytes & Avg. time \\ \hline \hline
{\tt lex}  & 68779 & 2.1 \\ \hline
{\tt flex} & 68815 & 2.0 \\ \hline
Hand-coded & 65728 & 1.9 \\ \hline
\end{tabular}

\vspace{8mm}

Variations in the load on the network resulted in a margin of error.
Because the results are so close we can not conclude that any one
scanner is significantly faster than the others.  Still, we can argue
that with speed not a factor, machine generated scanners are
preferable.

The difference in speed between the three different scanners is not
large enough to justify using it as the sole metric on which to judge
the scanners.  Any change in the language that requires a change in
the scanner will be significantly easier to effect using Lex or
Flex.  This is particularly important in young languages such as
Dee.  

Changing the machine generated scanners mostly involves altering the
regular expressions, with the exception of the small amount of C code
executed on a token match.  When the scanner generator is re-run, it
will use the new regular expressions to generate new tables.  Because
the tables in a hand coded scanner are maintained by the programmer,
altering them is a tedious and difficult task.

The hand-coded scanner does have several advantages over a machine
generated scanner.  It can determine the exact position of the token
on a line.  Knowing the column a token starts in can facilitate better
error reporting.  Both Lex and Flex can determine the line on which
tokens are found, but are unable to keep track of which column the
token begins or ends.  The hand-coded scanner results in a smaller
executable as noted in the table.  It is possible that a language may
require tokens to be matched which are not expressible as regular
expressions\footnote{ \{ $[^{i}]^{i} \mid i \geq 1$ \} is a well known
example.  Such scanners cannot handle nested comments.}. In this case,
a hand-coded scanner is required.

\section{The Parser}
\label{sec:parser}

The job of the parser is to determine if a given source program is
syntactically correct.  If syntax errors are found, they should be
reported to the user in a clear and concise manner.  If no errors are
found, the parser is responsible for organizing the source program in
a form suitable for semantic analysis and, eventually, code generation.
This form, in the case of the Dee compiler, is an Abstract Syntax Tree
(AST).  The Dee parser is generated by {\em Bison}, a parser generator
from GNU.  It is upward compatible with the standard Unix parser
generater called Yacc.

\subsection{The Bison Parser}

The Bison parser generator accepts as input, a specification for the
language to be parsed.  This specification is in the form of a grammar
augmented with a set of actions.  The grammar must be context free and
expressible as an LALR grammar.  The specification is basically a
machine readable grammar in Backus-Naur Form.  The actions are a list
of C statements that are executed when their corresponding syntactic
rule has been recognized.  Figure \ref{fig:MethBody} is an example of a
rule and its action from the Bison specification for Dee.

\begin{shortfigure}
\begin{verbatim}
MethBody      : BEGIN StatementList END
                                   { ThisBody = BodyConcrete;
                                     $$ = $2; }
              | SPECIAL
                                   { ThisBody = BodyInstr;
                                     ClassHasSpecial = TRUE;
                                     $$ = MakeInstr(); }
              | FROM IDEN
                                   { ThisBody = BodyFrom;
                                     $$ = MakeIdent($2); }
              | /* empty */
                                   { ThisBody = BodyAbs;
                                     $$ = NULL; }
              ;
\end{verbatim}
\caption{Bison specification for Dee method bodies.}
\label{fig:MethBody}
\end{shortfigure}

This rule indicates that a method body ({\tt MethBody}) can come in
one of four forms.  It can be a list of statements surrounded by the
keywords {\tt begin} and {\tt end}, the keyword {\tt special}, the
keyword {\tt from} followed by an identifier, or it can be empty.
{\tt StatementList} is a rule itself and is defined elsewhere in the
specification.  The tokens in all capital letters are terminal symbols
(i.e. {\tt SPECIAL}, {\tt FROM}, {\tt IDEN}, and {\tt BEGIN} ).  A
terminal symbol is recognized by the scanner and is not comprised of
constituent parts recognized by the parser.  Comments come in the same
form as those found in C (i.e., {\tt /* empty */}).

In order to compile a program, the compiler must know more than simply
an integer has been parsed, it must also know the value of that
integer.  Bison has a special semantic value mechanism for each
token.  Each terminal and nonterminal type can have a semantic value.
For terminal symbols, this often comes in the form of an integer
value, float value or identifier name.  For non-terminals it usually
comes in the form of a structure comprised of several semantic values.

The action part of the rule is written as a list of C statements.
Special symbols embedded in the code can be used to signify the
semantic value of each token.  The parser generator replaces these
special markers with their corresponding semantic values.  In the
first part of the example in Figure \ref{fig:MethBody}, the {\tt \$\$}
stands for the semantic value of {\tt MethBody} and the {\tt \$2}
stands for the semantic value of the second constituent of the rule
being recognized.  In this example, it stands for the semantic value
returned by {\tt StatementList}.  The semantic value of {\tt
StatementList} is returned as the semantic value of {\tt MethBody} if
the first portion of the rule is recognized.  Another example can be
seen in the action associated with the {\tt from} clause.  In this
case, the {\tt \$2} is used to pass the semantic value returned by
{\tt IDEN}.

The action taken when some non-terminals are matched results in the
creation of an AST.  This tree is a simplified version of the source
file.  It is simplified in the sense that many of the reserved words
are not present in the tree.  Their meaning in the language is retained
by the structure of the particular parts of the tree that they
correspond to.  Take, for instance, the part of the AST that
represents a Dee loop in Figure \ref{fig:loop}.

\begin{shortfigure}
\begin{verbatim}
      struct {
         AST FromStmts;    /* List of init. statements */
         AST UntilCond;    /* Boolean expression */
         AST WhileCond;    /* Boolean expression */
         AST LoopStmts;    /* List of loop statements */
      } Loop;
\end{verbatim}
\caption{Loop portion of the AST.}
\label{fig:loop}
\end{shortfigure}

We are only interested in the list of statements that make up the {\tt
from} part of the loop.  If there were no statements, {\tt FromStmts}
will point to nil.  Similar protocols are followed by the other parts
of the loop representation.

\subsection{Parser Evaluation}

It is not uncommon for academic language compilers to make use of
tools such as Bison and for commercial production compilers to
use hand coded parsers.  Commercial compilers tend to exist only for
languages that have gained some degree of popularity.  With this
extensive use, a language gains maturity and is less like to have
changes in its syntax.  Academic languages, on the other hand, are
often susceptible to modifications.  The choice of which parser to use
is primarily governed by two criteria: efficiency and ease of
modification.  For established languages, the tradeoff in
modifiability is worth the gain in speed.  For academic languages such
as Dee, the loss in efficiency is a small price to pay for the ease
with which a machine generated parser can be modified.

One example of the evolution of Dee syntax involves the way one writes
{\em special\/}\footnote{Special methods are the way in which Dee
interfaces with other languages and with the operating system.}
methods. The original version of the specification can be seen in
Figure \ref{fig:instr}.

\begin{shortfigure}
\begin{verbatim}
MethBody       :       INSTR               
                                   { ThisBody = BodyInstr;
                                     ClassHasSpecial = TRUE;
                                     $$ = MakeInstr( $1 ); }
               ;
\end{verbatim}
\caption{Parser specification for PC Dee special methods.}
\label{fig:instr}
\end{shortfigure}

{\tt INSTR} was recognized by the scanner as an identifier beginning
with the character '!' (ie. !add).  This notation came from the PC
version of Dee.  The funny looking identifier actually corresponded to
an instruction in the virtual Dee machine on which PC versions of Dee
programs run.  On the Unix version of Dee, special methods are
implemented directly in C.  This means that the name of the method and
the class in which it is found is enough information to make a special
method unique.  The funny identifier was replaced by the keyword {\tt
special}.  Because I used a machine generated parser, this change was
easy to effect.  I simply added the new keyword to the hash table of
keywords and changed the parser rule to look like what was seen in
Figure \ref{fig:MethBody}.

Hand coded parsers are more complicated from the compiler writer's
point of view and are much more prone to errors.  The simplicity that
makes machine generated parsers so easy to alter also has the added
benefit of making them less likely to contain errors.  The Dee parser
has been relatively free from bugs since the very beginning of the
development cycle.

While speed is not sufficient cause to write a hand coded scanner,
there is one flaw in Bison generated parsers that may warrant
this outlay of labor.  The error reporting capabilities are inadequate
in machine generated parsers in general and this is especially true in
the case of Bison.  It is quite easy to get the parser to report
that a syntax error occurred on a particular line.  It is quite
difficult to get it to report a more meaningful message and to recover
in a reasonable way.  Hand coded parsers are better able to give
sophisticated error messages and recover from errors.



\section{The Code Generator}

The {\em Code Generator} is the section of the compiler that takes a
decorated AST as input and produces C code as output.  The heart of
this section is the routine {\tt Gen()}, which recursivly traverses the
AST.  Each method in the AST that is implemented in the class
being compiled (with the exception of {\tt special} methods) causes one
C function to be generated.

\begin{shortfigure}
\begin{prog}
\>	method entry                            \\
\>	-- Generate all the prime numbers up to \\
\>	-- max using Eratosthenes' sieve        \\
\>\>	  var f:Filter i:Int max:Int            \\
\>\>	  begin                                 \\
\>\>\>	    max := 2000                         \\
\>\>\>	    f.make(2)                           \\
\>\>\>	    from i := 3                         \\
\>\>\>	    until i > max                       \\
\>\>\>	    do                                  \\
\>\>\>\>	f.process(i)                    \\
\>\>\>\>        i := i + 1                      \\
\>\>\>      od                                  \\
\>\>	  end
\end{prog}
\caption{Example of a Dee method}
\label{fig:deemeth}
\end{shortfigure}


\begin{shortfigure}
\begin{prog}
\>      void Primes\_entry( osp )               \\
\>\>		int osp;                        \\
\>	\{                                       \\
\>\>	  int Old\_hwm = hwm;                   \\
\>\>	  os[osp] = NIL;                        \\
\>\>	  os[osp+2] = NIL;                      \\
\>\>	  os[osp+3] = NIL;                      \\
\>\> 	  os[osp+4] = NIL;                      \\
\>\>      hwm = osp+5;                          \\
\>                                              \\
\>\>      os[osp+4] = create\_int( 2000, hwm ); \\
\>\>      os[osp+2] = NIL;                      \\
\>\>      os[osp+2] = CreateInstance( \_ClassTableIndex\_Filter, osp+2 ); \\
\>\>      os[osp+6] = os[osp+2];                \\
\>\>      os[osp+7] = create\_int( 2, osp+7 );  \\
\>\>      Call(Filter\_M\_make,5);              \\
\>\>      os[osp+3] = create\_int( 3, hwm );    \\
\>\>      do \{                                  \\
\>\>\>      os[osp+6] = os[osp+2];              \\
\>\>\>      os[osp+7] =  os[osp+3];             \\
\>\>\>      Call(Filter\_M\_process,5);         \\
\>\>\>      os[osp+6] = os[osp+3];              \\
\>\>\>      os[osp+7] = create\_int( 1, osp+7 );\\
\>\>\>      Call(Int\_M\_\_plus,5);             \\
\>\>\>      os[osp+3] = os[osp+5];              \\
\>\>\>      os[osp+6] = os[osp+3];              \\
\>\>\>      os[osp+7] =  os[osp+4];             \\
\>\>\>      Call(Int\_M\_\_gt,5);               \\
\>\>      \} while ( os[osp+5] != true\_object );\\
\>                                              \\
\>\>      hwm = Old\_hwm;                       \\
\>      \}  /* entry */                         
\end{prog}                    
\caption{C code generated from the Dee method {\tt Entry} for class
{\tt Prime}}
\label{fig:cmeth}
\end{shortfigure}

Figure \ref{fig:deemeth} is an example of a typical Dee method.  It is
the constructor for the class {\tt Primes}.  Figure \ref{fig:cmeth}
contains the C code generated for the Dee method in Figure
\ref{fig:deemeth}.  The name of the C function corresponding to a Dee
method is created by prefixing the name of the Dee method with the
name of the class it is implemented in and an underscore.

\subsection{The Run-time Data Structures}

Dee methods compiled into C functions do not use the C stack to pass
Dee arguments or return values.  Instead, all parameters and results
are conveyed using the Dee stack.  The {\em Dee stack} is a fixed size
array of pointers to objects.  This stack is used in much the same way
the C stack is used.  It contains a stack frame for each currently
active method.

\include{runtime}

Figure \ref{fig:runtime} is an example of the run-time data
structures, including a portion of the Dee stack.  The first pointer
in each stack frame is a pointer to the return value of the method.
It exists, but is ignored, in methods that do not return a value.
Following the return value is a pointer to the current object.  This
is the object that contains the method we are executing and whose
instance variables we have direct access to.

\begin{figure}
\setspacing{1}{
\begin{prog}
\>    struct Object \{              \\
\>\>    ClassPtr  Class;            \\
\>\>    struct GCFields Status;     \\
\>\>    union \{                    \\
\>\>\>    int     Int;              \\
\>\>\>    ObjectPtr Bool;           \\
\>\>\>    char *String;             \\
\>\>\>    double Float;             \\
\>\>\>    unsigned char Byte;       \\
\>\>\>    ArrayPtr ArrayBody[1];    \\
\>\>\>    ObjectPtr InstVars[1];    \\
\>\>\>    int GCStuff[2];           \\
\>\>    \} Tag;                     \\
\>   \};
\end{prog}}
\caption{The C declaration of a Dee object at run-time.}
\label{fig:object}
\end{figure}

Figure \ref{fig:object} shows the C declaration for the run-time
structure of an object.  The first field contains a pointer to the
class descriptor of which the object is an instance (see below for
a more detailed description of a class descriptor).  The second field
is used only for garbage collection and is explained in Section
\ref{sec:gc}.  The last field is a union which is used differently
depending on which class the object is an instance of.  The first five
fields in the union are used if the object is a base class.  Even in a
pure object oriented language, the basic building blocks of more
complicated objects must eventually have a representation in a form
directly usable by the CPU.  Even though Array is not a base class, it
is a special case.  The field {\tt ArrayBody} is a pointer to a
structure that contains information specific to arrays.  This includes
the bounds of the array and the actual array of pointers to objects.
The field {\tt InstVars} is an array of pointers to objects.  For
objects that are not of class {\tt Array} or a base class, this array
is sized to the number of its instance variables.  C can be {\em
tricked} into creating variable sized structures that allow us to
declare {\tt InstVars} to be only length two, but actually be the
correct size for objects that have more than two instance variables.
The C code in Figure \ref{fig:osize} calculates the number of bytes
needed for an object which has {\tt NumInstVars} instance variables.
The last field in the object data structure, {\tt GCStuff}, is used
only when the object is reclaimed by the garbage collector and placed
on the free list of objects.  It would have been possible to avoid
this extra declaration, but it helps keep the garbage collection code
simple by avoiding the need for frequent use of casts.  Since the {\tt
GCStuff} field is in a union, it costs nothing to include.  See
Section \ref{sec:gc} for more details.

\begin{shortfigure}
\begin{prog}
\>    AddOn = ( NumInstVars - 2 > 0 ) ? NumInstVars : 0; \\
\>    CorrectObjectSize =  \\
\>\>	sizeof( struct Object ) + AddOn * sizeof( * struct Object );
\end{prog}
\caption{C code to calculate the size of an object.}
\label{fig:osize}
\end{shortfigure}

\begin{shortfigure}
\begin{prog}
\>   struct Class \{        \\
\>\>   ClassType ClassKind; \\
\>\>   int InstanceSize;    \\
\>\>   int InstanceCount;   \\
\>\>   Parent ParentArray;  \\
\>\>   MethodPtr *Methods;  \\
\>   \};
\end{prog}
\caption{C run-time data structure for a Class.}
\label{fig:class}
\end{shortfigure}

Each class used, whether through inheritance or a client relationship,
by a particular Dee program contains a corresponding class descriptor
at run-time.  The C declaration for a class descriptor contained in
Figure \ref{fig:class} is also of variable size in much the same way
the object structure is.  In the case of the Class structure, it is
the number of methods that determines the size of the structure.  The
first field, {\tt ClassKind}, is a scalar that specifies whether the
class is a base, array, or regular class.  The {\tt InstanceSize}
field is the size of an instance in bytes.  {\tt InstanceCount} is the
number of instance variables in each instance of the class.  {\tt
ParentArray} is an array of pointers to the class structures of all
parents of the class.  It is used for testing conformance at run-time
and is explained in more detail in Section \ref{sec:exceptions}.

Referring back to Figure \ref{fig:runtime}, we see that above the
pointer to {\tt self}, are the arguments to the method.  Not every
method has arguments, but if it does, they are placed above {\tt self}
on the Dee stack, not on the C stack.  Finally, the top-most portion
of the stack frame contains the local variables for the method.  Upon
entry to the method all locals are initialized to point to the special
object {\tt NIL}.  The field {\tt result} is also set to {\tt NIL}
before the method is entered.  The {\tt NIL} object contains as many
methods as the class with the highest index into its method table.
Each method pointer for the class {\tt NIL} points to the {\em illegal
method}.  This method prints the message ``{\tt Attempt to send
message to uninitialized object.}'' and aborts the program.  Setting
uninitialized objects to point to {\tt NIL} prevents Dee programs from
crashing without an explanation if a message is sent to an
uninitialized object.  The last field, {\tt Methods}, is the variable
array of pointers to functions used to dispatch methods at runtime.
This field is covered in more detail in the Section
\ref{sec:applications} about generating code for method calls.

Two C variables are used to keep track of locations on the object
stack.  {\tt Osp} is the object stack pointer.  It always points to
the base of the current stack frame.  When a C function corresponding
to a method is called, its only argument is the new value of {\tt
osp}.  This is calculated in the calling method by adding the number
of parameters and locals variables in the current stack frame to the
current object stack pointer.  The global variable {\tt hwm} (for high
water mark) is always set to the highest location in use on the object
stack.  It is used by the garbage collector to scan the object stack
for all live objects.  Any locations on the stack above {\tt hwm}
contain garbage.  See Section \ref{sec:gc} for more details.

\subsection{Control Structures}

The mapping of Dee control structures to C control structures is quite
simple.  {\tt If} statements in Dee are directly mapped to {\tt if}
statements in C augmented with gotos.  The gotos are needed because
checking the Dee conditions may require some C code to be executed.
An example of a simple Dee {\tt if} statement and its corresponding C
code is found in Figures \ref{fig:dif} and \ref{fig:cif}.

\begin{shortfigure}
\begin{prog}
\>    if i < 5 then      \\
\>\>      k := i + 1;    \\
\>    elsif i > 10 then  \\
\>\>      i := 0         \\
\>    else               \\
\>\>      b := true;     \\
\>    fi
\end{prog}
\caption{An example of an {\tt if} statement in Dee.}
\label{fig:dif}
\end{shortfigure}

\begin{shortfigure}
\begin{prog}
\>    os[osp+6] = os[osp+2];                 \\
\>    os[osp+7] = create\_int( 5, osp+7 );   \\
\>    Call(Int\_M\_\_lt,5);                  \\
\>    if ( os[osp+5] == true\_object )  \{   \\
\>\>    os[osp+6] = os[osp+2];               \\
\>\>    os[osp+7] = create\_int( 1, osp+7 ); \\
\>\>    Call(Int\_M\_\_plus,5);              \\
\>\>    os[osp+4] = os[osp+5];               \\
\>\>    goto IF1;                            \\
\>    \}                                     \\
\>    os[osp+6] = os[osp+2];                 \\
\>    os[osp+7] = create\_int( 10, osp+7 );  \\
\>    Call(Int\_M\_\_gt,5);                  \\
\>    if ( os[osp+5] == true\_object )  \{   \\
\>\>    os[osp+2] = create\_int( 0, hwm );   \\
\>\>    goto IF1;                            \\
\>    \}                                     \\
\>    os[osp+3] = true\_object;              \\
\>    IF1:;
\end{prog}
\caption{The C code generated for the above Dee {\tt if} statement.}
\label{fig:cif}
\end{shortfigure}


Dee {\tt loop} statements are mapped into C {\tt while} statements.
Notice that the method {\tt Int\_M\_lt}, used to do the comparison
{\tt i < 5}, is called twice.  The first call is needed because the
condition must be checked before the body is executed.  If the
condition fails, the body will not be executed at all.  If the body is
executed at least once, the condition must be calculated again.
Calling {\tt Int\_M\_lt} the second time leaves the truth value of the
condition on the object stack for the C {\tt while} statement to
recheck.  The only difference in the code generated for Dee {\tt
while} and {\tt until} loop statements is that the condition is
negated in the {\tt until} version.  Figure
\ref{fig:dloop} shows the Dee code for a simple loop and Figure
\ref{fig:cloop} shows its corresponding generated C code.

\begin{shortfigure}
\begin{prog}
\>    from            \\
\>\>      i := 0      \\
\>    while           \\
\>\>      i < 5       \\
\>    do              \\
\>\>      i := i + 1  \\
\>    od
\end{prog}
\caption{A typical Dee {\tt loop} statement.}
\label{fig:dloop}
\end{shortfigure}

\begin{shortfigure}
\begin{prog}
\>    os[osp+2] = create\_int( 0, hwm );        \\
\>    os[osp+6] = os[osp+2];                    \\
\>    os[osp+7] = create\_int( 5, osp+7 );      \\
\>    Call(Int\_M\_\_lt,5);                     \\
\>    while ( os[osp+5] == true\_object )  \{   \\
\>\>    os[osp+6] = os[osp+2];                  \\
\>\>    os[osp+7] = create\_int( 1, osp+7 );    \\ 
\>\>    Call(Int\_M\_\_plus,5);                 \\
\>\>    os[osp+2] = os[osp+5];                  \\
\>\>    os[osp+6] = os[osp+2];                  \\
\>\>    os[osp+7] = create\_int( 5, osp+7 );    \\
\>\>    Call(Int\_M\_\_lt,5);                   \\
\>\>    \} /* while */
\end{prog}
\caption{The code generated for the above {\tt loop} statement.}
\label{fig:cloop}
\end{shortfigure}


See Section \ref{sec:exceptions} for information on the control
structures used in {\tt attempt} statements.

\subsection{Applications}
\label{sec:applications}

An application is the sending of a message in object oriented
parlance.  In more traditional terms, it is the invoking of a
procedure.  The first step in generating code for an application is
determining if the method is a constructor.  This can be determined by
examining information placed in the AST when it was decorated by the
semantic analyzer.  If it is a constructor, the receiving object must
first be created.  This is accomplished by calling the C function {\tt
CreateInstance()} with an argument specifying the class of the object
to be created.

After the type of the method is determined, the next step is to set up
a new stack frame above the current stack frame (see Figure
\ref{fig:runtime} for an example of a stack frame at run-time).  The new
result field is set to {\tt NIL}.  A pointer to the object receiving
the message is copied to the self field.  All the arguments are
calculated and copied into the argument slots above the self slot.
Calculation of the arguments often results in additional messages
being sent and, thus, additional stack frames being prepared above the
frame currently being built.  When additional stack frames are used to
calculate arguments, they are set up so that they will leave their
result in the slot for the argument.  After all the arguments are
calculated and stored in their correct slots, the method is ready to
be invoked.

The following is an example of the C code to call the method {\tt
make} in class {\tt Filter}.

\begin{prog}
\>  os[osp+off+1] -> Class -> Methods[Filter\_M\_make](osp+off)
\end{prog}

The variable {\tt off} points to the beginning of the new stack frame.
{\tt Os[osp+off+1]} is the slot in the object stack that points to the
object receiving the message.  The field {\tt Class} points to the
class structure of this receiving object.  The field {\tt Methods} is
the table of pointers to C functions corresponding to the methods for
the class which self is an object of.  The variable {\tt
Filter\_M\_make} is an index into this table, which was generated by
the Dee linker.  By making this a variable, we are able to insure that
the correct method is dispatched as long as the receiver is of the
correct type.

For example: Let there be a variable {\tt X} of class {\tt Shape} and
an application of the method {\tt show} to {\tt X}.
\begin{prog}
\>	var X : Shape   \\
\>	\vdots          \\
\>	X.show          \\
\end{prog}
In addition, there are three classes {\tt Circle, Square} and {\tt
Oval}, which all inherit class {\tt Shape}.  {\tt Square} and {\tt
Oval} both implement their own versions of the method {\tt show}.
\begin{prog}
\>	class Circle    \\
\>	inherits Shape  \\
\>	\vdots          \\
\>                      \\
\>	class Square    \\
\>	inherits Shape  \\
\>	method show     \\
\>\>	begin           \\
\>\>	  \vdots        \\
\>\>	end             \\
\>	\vdots          \\
\>	                \\
\>	class Oval      \\
\>	inherits Shape  \\
\>	method show     \\
\>\>	begin           \\
\>\>	\vdots          \\
\>\>	end             \\
\>	\vdots
\end{prog}
At run-time, it is possible that {\tt X} will be an instance of class
{\tt Shape, Circle, Square} or {\tt Oval}.  But no matter what class
{\tt X} happens to be a instance of, for this particular application,
the method {\tt show} for that class will be invoked.  The Dee linker
guarantees that the pointer to the method {\tt show} is at the same
offset in the method table for each of the classes that inherit {\tt
Shape}.  If the method {\tt show} is implemented in class {\tt Shape},
it too will be at that same offset.  Since that offset can only be
determined at link-time, that Dee linker emits a declaration for the
integer variable {\tt Filter\_M\_make}, and assigns the correct offset
to it.

\subsection{Assignments}

Assignments come in two forms: assignments to local variables of the
currently executing method and assignments to the instance variables
of the object currently executing a method.  It is illegal to assign
to an instance variable of any object but the current object.  Dee
syntax rules prevent these types of assignments.

In the following example,
\begin{prog}
\>    foo := 3
\end{prog}
if {\tt foo} is a local variable, the C function {\tt create\_int()} is
called to create an instance of the class {\tt Int} with a value of 3.
This object is then assigned to the correct slot in the active stack
frame.  If the offset for the variable {\tt foo} is 4, the code
generator would produce the following C code for this example.
\begin{prog}
\>    os[osp+4] = create\_int( 3 );
\end{prog}

If {\tt foo} is an instance variable it must belong to the object in
the self slot of the currently active stack frame.  Because
instance variables may be inherited in much the same way methods are
inherited, we index the table of instance variables with a variable
that is defined by the Dee linker.  The code generated in this second
case would be as follows.
\begin{prog}
\>    os[osp+1] -> Tag.InstVars[SomeClass\_V\_foo] = create\_int( 3 );
\end{prog}
We know which slot in the stack frame points to the current object
because {\em self} is always in the slot one above the top of the
stack.  The variable {\tt SomeClass\_V\_foo} is generated in exactly
the same way as was the variable used to access method table in the
previous example except that a {\tt \_V\_} replaces the {\tt \_M\_}
used in method table index variables.

\subsection{Code Generator Options}

There is one command line argument to the Dee compiler, which is
passed to the code generator.  By placing a {\tt -V\#} after the name
of the file be compiled, where {\tt \#} can be 0, 1, 2 or 3, the user
can control the verbosity of the C code generated.  Zero is the
default and produces C code which is not particularly easy for humans
to read.  As the numeric portion of the {\tt -V} switch gets closer to
3, the code generator emits increasingly more verbose C code.  The
code produced by using an argument of 3 is not legal C code and can
not be compiled, but is especially easy for humans to understand.  For
level 3, local variable stack offsets are replaced with the Dee name
of the local variable.  This feature is particularly useful when
attempting the difficult task of debugging the generated code or when
trying to write Dee {\tt special} methods.



\section{Exceptions in Dee}
\label{sec:exceptions}

Dee has facilities for generating and handling exceptions (see Section
\ref{sec:except} for an explanation of these terms).  An exception in
Dee comes in the form of an exception object.  For example, the
following line of code raises an exception of class {\em String}:

\vspace{3mm}
{\tt signal "Division by zero."}
\vspace{3mm}

An exception object can be an instance of any class.  When the
exception is signaled, the exception object is bound to the {\em
exception register}.  

The programmer can write code to handle the exception by using the
{\tt attempt} statement whose generic form is shown in Figure
\ref{fig:attempt}.

\begin{shortfigure}
\begin{prog}
\>      attempt                      \\
\>\>      $S$                        \\
\>      handle  $x_{1}$ : $C_{1}$    \\
\>\>      $S_{1}$                    \\
\>      \vdots                       \\
\>      handle $x_{n}$ : $C_{n}$     \\
\>\>      $S_{n}$                    \\
\>      end                          
\end{prog}
\caption{Basic form of an {\tt attempt} statement.}
\label{fig:attempt}
\end{shortfigure}

If an exception is generated\footnote{And it is not caught by a
handler at level closer to the code that generated it.} by $S$, the
system will attempt to determine if it matches any of the handlers in
the current {\tt attempt} statement.  This is accomplished by testing
if the exception object conforms to each class $C_{n}$ starting with
$n$ equal to 1.  If the exception object does conform to a class
$C_{n}$, it is bound to the corresponding variable $x_{n}$ and the
statements, $S_{n}$, corresponding to that handler are executed.  If
no match is found in the current scope of handlers, the next level of
exception handlers is tried.  Eventually, if no match if found, the
run-time system will print the message ``Unhandled exception.'' and
cease execution.


\subsection{Implementation}

When an exception occurs at run-time, the system will have to
determine which handler will accept it.  Because of the semantics of
Dee, it is necessary to test the exception object for conformance to
the class of each potential handler.  This test requires that the
inheritance graph be available at runtime.

The inheritance graph is actually embedded in the class structures
that exist at runtime.  Each class structure has a field ({\tt
Parent}) that points to a variable length array of integers terminated
by a -1 in the last slot.  If the class has no parents, then {\tt
Parent} points to {\tt NULL}.  The integers contained in the array are
indices into the global array ({\tt ClassTable}) of pointers to the
actual class structures.

\input{except}

It would be quicker to test conformance if {\tt Parent} were an array
of pointers to the classes.  This would avoid an extra indirection but
the addresses in memory of the class structures are not known at
link-time. It would be possible to generate code that, when the
program is first run, would fill in {\tt Parent} array, but this would
slow down the start up time for all programs.  

The C function {\tt Conforms()} is called at run-time to determine if
the class of the exception object conforms to the class of each
handler.  If a match is found, the exception object is bound to the
identifier in the signature for that handler and the code for that
handler is executed.  {\tt Conforms()} tests conformance by recursively
traversing the list of parents, contained in the {\tt Parent} array,
all the way up the inheritance graph trying to find an exact match
between the class of an ancestor and the class of the exception
object.  If such a match is found, {\tt Conforms()} returns true,
otherwise it fails and the next potential handler uses {\tt
Conforms()} again.  Because inheritance sub-trees tend not to have an
extremely large number of nodes (classes), traversal is not an expensive
operation to perform.

The C functions {\tt setjmp()} and {\tt longjmp()} are used to save
and restore context.  Each time an {\tt attempt} statement is entered,
a new block of C code is created with a local variable to save the
current context using {\tt setjmp()}.  After the context is saved in
the local variable, it is placed on a stack of saved contexts.  When a
signal is raised, we do a {\tt longjmp()} to the context at the top of
the stack.  If no handler is found, we pop the next context on the
stack and do a {\tt longjmp()} to its stored context.  Declaring each
element on the list as a local variable does not require us to
allocate and deallocate memory each time an {\tt attempt} statement is
entered.  If the statements inside the the {\tt attempt} body complete
without causing an exception to be raised, the stack is popped but no
{\tt longjmp()} is executed.  The action of popping the stack removes
the element from the stack.  The variable is reclaimed automatically
when the block is exited.  This technique is a modified version of the
ideas presented in \cite{Dony90} and \cite{Amsterdam91}.

\section{Dee Mode for Emacs} \label{dee-mode}

Emacs is one of the most commonly used editors used on Unix systems.
Much of this popularity is due to its power and flexibility.  Emacs is
partly written in C and partly in Emacs Lisp.  The C part of Emacs
consists of a Lisp engine and a large number of functions callable
from Lisp.  A significant part of the editor is written in Emacs Lisp
and runs on this engine.  To extend Emacs one writes additional Emacs
Lisp code or changes the existing code.

When editing a program using Emacs, the editor is usually in a {\em
major mode} which provides editing features specific to the type of
file being edited.  Major modes exist for the C and Lisp programming
languages and for natural languages.

I have written a major mode for Dee, to assist programmers in writing
Dee source code.  It can insert the skeleton of all the major
programming constructs.  For instance, typing the key sequence {\tt
C-c l} (a control-C followed by the letter 'l') will insert the
following text at the cursor
\vspace{8mm}
\begin{verbatim} 
  from
  while
  do
  od
\end{verbatim}
\vspace{8mm}
and indent it correctly.  It will leave the cursor after the {\tt
from} statement as this is where the user will most likely start
typing. Having the editor insert text avoids mistakes in syntax and
spelling that are usually caught by the compiler.  This, in turn,
speeds up the development cycle.

Whenever a tab or return is hit, Dee mode will automatically attempt
to correctly reindent the current line and, in the case of a return,
indent correctly on the new blank line.  Aside from saving the
programmer many keystrokes, this indentation can aid in the early
detection of syntax errors.  It is usually easy for the programmer to
know how much any given line of code should be indented.  If Emacs
does not indent a line as the programmer expected, it usually
indicates a mistake in the code above that line.

Because Dee mode prevents and detects errors at an early stage in the
process of writing programs, it reduces the amount of time the
programmer spends in the edit-compile loop.  This, in turn, increases
programmer productivity.

Perhaps the most useful feature of Dee mode is its built-in browser.
When the cursor is placed on a word that is the name of a class
already written to the CIDB (Class Interface Data Base), the interface
of that class can be viewed.  After invoking the Dee mode browse-class
command with the keystrokes {\tt C-c b}, an additional window is opened and
the interface for the selected class is displayed in it.  Every time a
new class is selected with these keystrokes, its interface is shown in
this window.

In the case of a class interface that is frequently referred to, the
user can browse in a different way.  By selecting the class in the same
way, but by then invoking the perm-browse-class command with the
keystrokes {\tt C-c B}, a permanent window is created and the interface for
the selected class is displayed in it.  This window is permanent in
the sense that browsing another class with the browse-class command
will not overwrite it.  As many of these permanent browse windows can
be created as needed.

If a class that has already been permanently browsed, is selected
again, the old interface is overwritten.  This is because the class
may have been recompiled and the system must be careful never to
present two different interfaces to the same class at the same time.

The browser in Dee mode is not meant to replace a more user friendly X
windows browser, but it does have its place.  Although Emacs can be
used with a mouse, it was primarily designed to work without one.
Experienced Emacs users often prefer to avoid touching the mouse
whenever possible.  Incorporating the browser in Dee mode allows them
this freedom.  Many users of Dee will not have X windows or other
suitable windowing environment, they may have insufficient hardware or
be working over a phone line.  Dee mode gives them all the
functionality of a graphical browser but without the fancy (and
probably more friendly) user interface.

Emacs may not be the primary editor in the complete version of
the Dee system, but it is a valuable alternative.  Many Unix
programmers already know how to use Emacs and should not be
forced to use a special Dee editor.  Experienced Emacs users
have the option of performing their own customizations in addition to
those provided by Dee mode.

\section{Garbage Collection}
\label{sec:gc}

Garbage collection is the process of reclaiming memory that is no
longer needed by a program.  Memory can safely be considered {\em
garbage} when it is no longer reachable from global variables, active
stack variables or through a chain of pointers starting from these
locations.  When a portion of memory is {\em collected} it is returned
to the pool of memory available for future use.  Because Dee is a pure
object oriented programming language, memory that the garbage
collector deals with is always in the form of an object.  I will
therefore use the term {\em object} to describe the unit of memory
that garbage collectors operate on.  In other languages, memory might
contain smaller units such as integers, pointers or characters.

\subsection{Types of Garbage Collectors}

The most common types of garbage collection include reference
counting, mark-and-sweep, and stop-and-copy.  This section contains a
full explanation of these algorithms.  The first collectors where
implemented by McCarthy \cite{Mccarthy60} and Collins \cite{Collins60}
in the early 60s.  These were of the mark-and-sweep and reference
counting variety.  As technology increased, virtual memory allowed
large heap space.  As a result, stop-and-copy collectors started
appearing in the last 60s.

In addition to the methods mentioned above, Goldberg and others
\cite{Goldberg91,Marshall70,Branquart70} have shown that strongly
typed programming languages can implement garbage collection which
is specific to each program.  This method has the advantage of
avoiding tags, used to determine the type of an object, normally found
in conventional collectors.

By having the run-time system automatically reclaim memory when it
becomes garbage, we free the programmer from this difficult task.
Boehm and Weiser \cite{Boehm88} show that when garbage collection is
added to C programs, previously unknown memory leaks are often found.

\subsubsection{Reference Counting}

{\em Reference counting} \cite{Collins60} basically consists of
keeping a count of the number of references to each object.  When the
count drops to zero, the object is unreachable and thus garbage.  It
may then be collected.  Reference counting has several disadvantages.
It is not possible to reclaim a circular list of objects even though
it is not reachable from the active variables.  Because the list
contains a loop, none of its components have a zero reference count.
Ways to overcome this problem have been implemented, but they often
have a negative affect on the programming style because programmers
are required to make consious efforts to avoid loops.  This
restriction reduces the main benefit of automatic garbage collection,
that it should be transparent to the programmer.  Reference counting
requires space for a reference count and maintaining this count
consumes considerable overhead.  In some implementations, every store
instruction has some garbage collection overhead associated with it.

\subsubsection{Mark-and-Sweep}

{\em Mark-and-Sweep} collection is a two phase process.  The {\em
mark} phase is a traversal of all live memory.  A bit is set in a tag
associated with each portion of memory that is reachable.  The {\em
sweep} phase then reclaims all memory that does not have the bit in
its tag set.  This algorithm has the disadvantage of needing to
traverse the entire address space of a process in order to return
unmarked objects to the free store.  It also has a space overhead of
at least one bit per object.  Unlike reference counting,
mark-and-sweep algorithms do reclaim unreachable circular structures.

\subsubsection{Stop-and-Copy}

{\em Stop-and-Copy} collectors avoid the overhead of traversing all of
a process' memory by copying all live data to a new area.  Once all
live data in a region has been copied out, the entire region can be
reclaimed without being examined in detail.  To copy the live data out
of a region the algorithm traverses only the live data.  As each live
object is reached, it is copied to a new region.  After the copying is
completed, all pointers must be updated to reflect the new location of
each object.  This technique requires more memory than other
techniques because memory must be divided into (at least) two
different regions, each large enough to hold all live objects with
room left over.  Stop-and-copy collectors have an advantage in that
they do not scan all memory, only that which contains live objects.
In addition, copying collectors compact data as it is copied to the
new region, eliminating the need for a separate compaction phase.

\subsection{Generational Collectors}

{\em Generations} are an extension to the above collection algorithms
that allow objects that have been alive for longer periods of time to
avoid being considered for collection.  Generational collectors were
first introduced by Liberman and Hewitt \cite{Lieberman83}.  They make
use of the fact that as objects age, they are less likely to become
garbage.  In this type of collector, heap space is divided into
several sections called {\em generations}.  Each time the collector is
invoked, it increments the age counts of all live objects.  When an
object reaches a threshold age it is copied to the next generation.
This process of moving objects to a new generation is called {\em
promoting}.

As a result of promoting, objects that are less likely to become
garbage are concentrated in the older generations.  When space is
needed, the collector can affect only the youngest generations where
the ratio of garbage to active objects will be highest.  Collection in
older generations occurs less frequently than in younger generations,
usually when not enough space was reclaimed from passes on earlier
generations.

Generations have been added to both mark-and-sweep collectors
\cite{Zorn90} and stop-and-copy \cite{Ungar84}.  

\subsection{Garbage Collection in Dee}

The Dee garbage collector is of the mark-and-sweep variety.  To avoid
some of the disadvantages normally associated with this type of
collector, it was augmented with generations.  Currently, the Dee
collector implements four generations but this can be easily changed.
Each generation consists of a linked list of large pieces of memory
called {\em chunks}.  Chunks are obtained through calls to {\em
malloc()}.  Dee Objects are allocated from these spaces and are never
split across chunk boundaries.  See Figure \ref{fig:chunks} for an
illustration of these data structures.  The design constrains Dee
objects to be no larger than the size of a chunk.  Chunk size,
currently 4K, is hard-coded into the run-time system but may become a
compile time option in a later version of the Dee system.

Free space is maintained by keeping a linked list of unused areas
pointed to by a header unique to each chunk.  The nodes in the list
are portions of unused space right in the chunk.  Each node in the
list contains a field indicating how much space is free at that point,
and pointers to the next and previous free slots.  Keeping a doubly
linked list will allow us to change the algorithm used to maintain the
free list without much difficulty.  Currently, free space is returned
to the front of the list and is allocated by a first fit algorithm.

\begin{shortfigure}
\centerline{\hbox{
\psfig{figure=chunks.ps}}}
\caption{The memory management structures used by the collector and allocator.}
\label{fig:chunks}
\end{shortfigure}

Whenever a new object is needed, the routine {\tt Oalloc()} is called
instead of {\tt malloc()}.  {\tt Oalloc()} traverses the list of
chunks in the first generation until it finds one with a slot large
enough to satisfy the request.  The slot is removed from the free list
and its address is returned.  If the slot was bigger than the amount
requested, the remainder of the slot is kept on the free list unless
it is less than the minimum size of an object (this special case is
discussed below).  If no acceptable slot is found then a new chunk is
allocated and the new object slot is taken from it.  Before the new
chunk is allocated, the garbage collector is invoked.  Even if enough
space is recovered to satisfy the current call to {\tt Oalloc()}'s
needs, a new chunk is still allocated.  This helps prevent the
collector from being called too frequently as a result of only a small
amount of memory being reclaimed.

\subsubsection{Fragmentation and padding}

One of the weaknesses of the current Dee implementation is that the
minimum size of an object is 16 bytes on most 32-bit processors.  This
is a result of design decisions made before garbage collection was
considered, but it does result in some benefits for the collector.  If
a slot being allocated from the free list is bigger than the new
object but not so big that the remainder could contain another object,
it is treated as a special case.  Instead of being placed on the free
list, this extra memory is allocated with the memory requested.  Eight
bits in each object are used to determine how much {\em padding} each
object has.  This has the disadvantage of wasting bits in each object
and bytes in fragmented chunks.  Padding objects has the advantage of
making compaction unnecessary.  Whenever an object is reclaimed, it is
always at least large enough to contain a base object.  In practice,
not many bytes are consumed by fragmentation because base objects
(which are always the minimum legal size of an object) are created and
reclaimed so frequently.  Slots smaller than the minimum object size
can never exist on the free list.  When a chunk is swept, adjacent
garbage slots are compacted together further eliminating
fragmentation.

\subsubsection{Marking}

During the mark phase of collection, each active object must be
flagged in some way.  After the sweep phase, these flags must be
cleared.  The method used by Zorn \cite{Zorn90} maintains a bit map
for each chunk of memory.  The mark/test/clear operations on a bit map
have the advantage of being very localized but expend the overhead of
a table lookup.  Locating the tag next to, or in, the object with
which it is associated results in touching each active object three
times for each collection: once to set the bit, a second time to test
it when sweeping and a third time to clear all the set bits in
preparation for the next collection.  Localization becomes a factor on
the clear operation.  If each active object must be touched a third
time, we lose much of the advantage gained by having generations.  To
solve this problem and avoid the expense of table lookup associated
with the bit map method, I have used a mark field of eight bits
instead of one.  This allows me to set the mark field to the current
mark counter.  When sweeping, I simply test the mark field with the
current mark counter; a match means the object is alive.  The mark
count is incremented once in each collection phase, but zeroed when it
reaches 255.  There is no need to clear the mark field as long as I
ensure that no object ever goes more than 256 collection cycles
without being swept.


\subsubsection{Sweeping}

Sweeping occurs on a per generation basis.  After a mark phase, any or
all of the generations may be swept depending on the current
configuration of the collection strategy.  A complex strategy might
even choose to sweep only some of the chunks in a particular
generation.  

The sweep algorithm starts at the top of a chunk.  An object always
starts at the first address in the chunk.  When chunks are created,
they are initialized to contain at least one object.  As they are
filled with live objects and go through the reclamation process, they
are always in a consistent state.  Each object in the chunk is either
a live object, a dead but not reclaimed object, or an empty slot on
the free list.  If an object is on the free list, a single bit is set
to signal this state.  Objects that do not have this bit set are
either alive or ready to be collected.  The former are left untouched
but the later are moved into the free list.  If an object is not on
the free list, we can determine its size by using the field, which
every object contains, that points to its class structure.  The class
structure has a field giving the size of an instance of that class in
bytes.  This size is added to the number in the padding field to
determine where the next object in the chunk begins.  When an object
is garbage, we use the fact that it is never less than 16 bytes to place
the free list pointers and size field over its old data fields.  All
consecutive garbage objects and slots in the free list are combined to
make the largest possible free list slot.

When an object is reclaimed during the sweep phase, its class is checked
to determine if it needs special treatment.  Instances of the classes
{\tt Array} and {\tt String} contain pointers to memory that was
allocated directly by a call to {\tt malloc()}.  These fields must be
returned by calling {\tt free()}.  If other special base classes are
added to the Dee system, they may also have to be reclaimed in this
manner.

\subsubsection{Promoting Objects}

Right after a live object is marked, its age field is also
incremented.  If the age reaches a preset threshhold, the object is
promoted.  The first step in the promotion process is to allocate
space for the object in the next older generation.  A function called
{\tt NewGenSlot()} is called to find this new space.  {\tt
NewGenSlot()} is very similar to {\tt Oalloc()}.  They differ in that
{\tt Oalloc()} only allocates space from the yongest generation while
{\tt NewGenSlot()} only allocates from generations older than the
first.  {\tt NewGenSlot()} automatically determines the generation of
the object passed to it by examining its {\tt Gen} field.  It uses
this information to decide which generation to allocate from.  The
correct amount of space needed in the new generation is determined by
using the {\tt Class} field in the object being promoted.  The class
structure has a field that contains the number of bytes any instance
of that class will require.

Before copying the object into the new generation, a temporary
variable is used to save the amount of padding contained in the slot
returned by {\tt GenNewSLot()}.  The amount of padding in an object is
completely determined by where the object is allocated.  It would be
incorrect to copy the padding from the object at its original location
to the new location. 

After Space has been allocated in the new generation, the object is
then copied into this new space.  The amount of padding, saved in a
temporary variable, is copied into the new slots {\tt Pad} field.  At
this point, two copies of the object exist.  We must be sure that the
old copy will be reclaimed during the sweep phase, and that the new
object will be left alone.  This is acomplished by marking the new
location as live, and leaving the old copy unmarked.  In addition, we
must adjust the {\tt Gen} field in the new copy to reflect its home in
a new generation.

The final phase of promoting an object is to readjust all live objects
in the system that point to the old copy.  This is acomplished by
setting a bit in the old object that signals that it has been promoted.
This bit, named the {\tt Promo} bit, is used in a second traversal of
live objects.  After setting the {\tt Promo} bit, a pointer to the new
location of the object is placed into one of the fields of the old copy.
This is harmless because we have a new copy of the object.  In the
second traversal, every pointer is dereferenced to determine if it
points to an object with its {\tt Promo} bit set.  If the {\tt Promo}
bit is set, the pointer is overwritten with a copy of the new address
of the object found in the old copy's {\tt InstVars[0]} field.  This
technique of pointer updating is a modified version of an algorithm
found in \cite{Cohen83}.

The second traveral of all live objects is only carried out if at
least one object has been promoted.

\subsubsection{Performance and Tuning}

Because the Dee system is in its infancy, it lacks a large application
base on which the garbage collection subsystem could be tuned to
optimum performance.  This section contains an explanation of all the
parameters that might help a future programmer optimize the garbage
collector.

The size of a chunk can be altered by changing the constant {\tt
CHUNK\_SIZE}.  It is currently set to the size of a page on the SPARC
stations.  If large objects are being created it makes sense to
increase the size of a chunk to several times that of a single page.
This variable might also change if the Dee system is ported to new
hardware with different characteristics.  

Free slots placed on the free list are always added to the beginning of
the list.  The list is always searched from begining to end, employing
a {\em first fit} strategy, when allocating new slots.  {\tt
AddToList()} could be changed to maintain the free list in a some
other order.  The allocation routine {\tt Oalloc()} could be changed
to dole out slots in a different fashion, such as {\em best fit}.

The most significant factor affecting the garbage collector
performance is determining when it is invoked and on which
generations.  The more often the collector is run, the less memory is
used by the program.  This is because garbage is recycled sooner.
Frequent collections have the disadvantage of slowing down the
program.  

Having a generational collector allows us to call the collector
frequently without causing noticible pauses in program execution.
Each time the collector is called we can choose to sweep only a
portion of total memory.  Currently, the Dee run-time system only
calls the garbage collector when the first generation is completely
full.  Before a new chunk is added to the first generation, the
collector is always run.  This causes a cycle in the growth of the
first generation.  When the generation is full, it is swept and then
its size is increased by one chunk.  Because the first generation
contains young objects, a very large percentage of the memory it
contains is reclaimed.  It then fills up again and repeats the cycle.
This has the disadvantage of allowing a program that runs for a long
time to indefinitely increase the amount of memory it consumes.

A different approach would be to call the collector on the first
generation whenever memory usage reaches a predetermined threshold.
Each time the routine to allocate new objects ({\tt Oalloc()}) is
called, it would keep statistics about memory usage.  The threshold
could be set to eighty percent capacity of the total amount of memory
available in the generation.  If a suitable amount of memory is not
reclaimed, another chunk could be added.  This algorithm would have
the advantage of keeping the amount of memory allocated to the program
to a minimum but would also result in an increased number of calls to
the collector.  The increased number of calls to the collector would
slow down the program.

Everytime the collector is called, it must make a decision about how
much memory is to be swept.  In the current Dee collector, the first
generation is swept every time, the second is swept every seventh time
and the third is swept every seventeenth time.  It is easy to adjust
the collector to sweep different generations at different intervals.
Some simple tests revealed that increasing the frequency of sweeping
caused noticeable pauses in the program with only minor decreases in
the total amount of memory consumed.  Using the above intervals
prevents the collector from sweeping the second and third generation
in the same invocation to often.  The choice of the sweeping intervals
was based on estimates and a small number of tests.  After larger,
more sophisticated Dee programs are written, better test may cause
them to be adjusted.

Ungar and Jackson \cite{Ungar88} have shown that objects which live
long enough to reach the oldest generation become garbage at a very
slow rate.  For this reason, the oldest generation in the Dee
collector is never swept.  Turning collection on for the oldest
generation in a few test programs showed no reduction in the number of
chunks allocated to the final generation over runs with collection
turned off.  This policy can result in memory leakage.  It would be
better to sweep the last generation, but only at very distant
intervals.

The current version of the Dee garbage collector maintains a large
number of statistics.  These are used for debugging and for tuning the
algorithm.  At the end of every Dee program a few of these statistics
are printed.  Figure \ref{fig:stats} shows the last portion of the
output of the Primes program.  This program calculates the Prime
numbers up to 2000 using Eratosthenes' sieve.  It creates a {\em
filter} object for each prime number.

\begin{shortfigure}
\begin{verbatim}
1951 
1973 
1979 
1987 
1993 
1997 
1999 

Bytes Oalloced = 1661204, Bytes Malloced = 80864
Chunks per Gen: 58, 5, 5, 8
\end{verbatim}
\caption{Code generator statistics.}
\label{fig:stats}
\end{shortfigure}

The number for {\tt Bytes Oalloced} is the amount of memory that would
have been allocated to the program if it had had no garbage collection.
If a compiler option is added to Dee to turn off garbage collection,
it can be implemented by placing a simple test at the beginning of the
{\tt Oalloc()} routine.  If ``No collection'' is flagged, then {\tt
Oalloc()} would simply call {\tt malloc()} to get the number of
requested bytes.

The amount for {\tt Bytes Malloced} is the actual number of bytes
allocated by calls to {\tt malloc()}.  It is the total number of bytes
dynamically allocated at run-time.  This number is also the number of
chunks allocated multiplied by the size of a chunk.

The {\tt Chunks per Gen} data are the number of chunks allocated
for each generation.


\section{Base Classes}

Base classes are classes that contain a component which is not a
pointer to another class.  This component comes in the form of a piece
of data that can be manipulated directly by the processor.  Base
classes also differ from regular classes in that they have a very
intimate relationship with the code generator and the run-time system.

Even though Dee is a pure object oriented programming language, it
must contain data in a form that is manipulatable by the CPU.  Regular
objects contain instance variables that are pointers to instances of
a particular class.  Base classes have only one instance variable, and
this variable is of a special nature.

\begin{shortfigure}
\begin{prog}
\>   struct Object \{                \\
\>   ClassPtr  Class;                \\
\>   struct GCFields Status;         \\
\>   union \{                        \\
\>\>    int Int;                     \\
\>\>    ObjectPtr Bool;              \\
\>\>    char *String;                \\
\>\>    double Float;                \\
\>\>	unsigned char Byte;          \\
\>\>	ArrayPtr ArrayBody[1];       \\
\>\>    ObjectPtr InstVars[1];       \\
\>\>	int GCStuff[2];              \\
\>\>    \} Tag;                      \\
\>   \};
\end{prog}
\caption{The run-time data structure for an object.}
\label{fig:object2} 
\end{shortfigure}

Figure \ref{fig:object2} shows the C data structure that represents an
object at run-time.  The first five fields in the variant part of the
structure are used to implement the data that is unique to base
classes.  For example, if the structure is an integer at run-time, the
{\tt Int} field will hold its integer value.  This {\tt Int} field can
only be manipulated by {\tt special} methods of the class {\tt Int}.
The fields for float and byte are used in the same manner.  The fields
for string and boolean classes are used a bit differently.  

The field {\tt String}, used only by the string class, points to an
array of characters in memory.  This field is created by the run-time
function {\tt CreateInstance()} or by a special method of the string
class.  These functions use {\tt malloc()} to allocate the memory
that actually holds the characters of the string.  It would have been
difficult to place the characters of the string directly in the
structure of the object because strings in Dee are of variable length.
They grow and shrink automatically to fit the size of the string that
they hold at the moment.

The field {\tt Bool} can only point to one of two objects: the false
object or the true object.  The two objects are created before any
other Dee statements are executed.  In order to test the truth value
of an object of class {\tt Boolean}, we test the {\tt Bool} field to
see which of these two objects it points to.

Using a variant record to hold the different possible values
associated with each type of base class saves memory, but at the cost
of adding one restriction to the inheritance rules.  It is not legal
to inherit from a base class in Dee.  If this were allowed, it would
be necessary to have distinct slots for all the different base class
data values.

\begin{shortfigure}
\begin{prog}
\>    void Int\_\_plus( osp )         \\
\>\>      int osp;                    \\
\>    \{                              \\
\>\>      os[osp] = CreateInstance( \_ClassTableIndex\_Int, hwm ); \\
\>\>      \\
\>\>      os[osp] -> Tag.Int =        \\
\>\>\>	     os[osp+1] -> Tag.Int + os[osp+2] -> Tag.Int; \\
\>    \}  
\end{prog}
\caption{The {\tt special} Dee method to add two integers.}
\label{fig:plus}
\end{shortfigure}

Figure \ref{fig:plus} shows the special method used to add two
integers together.  The first C statement creates a new instance of
the {\tt Int} class and places it in the result slot of the current
Dee stack frame.  The second C statement adds the {\tt Int} fields of
the object passed to the method and the object in the self field of
the current Dee stack frame.  Their sum is assigned to the {\tt Int}
field of the integer object just placed in the result slot.  This is
typical of how the special methods of the bases classes actually
manipulate data contained in the base class data fields.  Appendix B
contains the complete Dee and C source code for the base class {\tt
Int}.

One should also note the name of the special method in the above
example.  As mentioned in Section \ref{sec:parser} on the parser, the
infix operators, like ``{\tt +}'', are transformed into regular
identifier names prefixed with an underscore.  This allows programmers
to follow the same method naming convention used when the compiler
generates stubs for all the other Dee special methods.



